// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import {ISablier} from "@sablier/protocol/contracts/interfaces/ISablier.sol";
import {Initializable} from "@openzeppelin/proxy/utils/Initializable.sol";
import {IERC20} from "@openzeppelin/interfaces/IERC20.sol";
import {TerminationClauses, Agreement} from "contracts/lib/Types.sol";
import {AgreementArbitrator} from "contracts/AgreementArbitrator.sol";

import {console2} from "forge-std/console2.sol";

/// @title ContractooorAgreement
/// @author @colinnielsen
/// @notice Arbitrates agremements between Service Providers and Service Receivers
contract ContractooorAgreement is Initializable {
    error NOT_RECEIVER();
    error NOT_SENDER_OR_RECEIVER();
    error INCOMPATIBLE_TOKEN();
    error INVALID_END_TIME();

    AgreementArbitrator private arbitrator;
    ISablier private sablier;
    Agreement public agreement;

    constructor() {
        _disableInitializers();
    }

    /// @notice initializes this agreement and begins a stream with the current tokens of this contract
    /// @notice SPEC:
    /// This function will begin a new stream with the contract's balance of tokens to the recipient given:
    ///     I1. The `sablier` param is a compliant sablier implementation
    ///     I2. The `streamToken` param is a compliant ERC20 token
    ///     I3. This contract has at least `tokensToStream` amount of `streamToken`
    ///     SABLIER SPEC:
    ///     S1. `agreement.recipient` is none of the following: the 0 address, the `_sablier` contract, this address
    ///     S2. `tokensToStream` is not 0
    ///     S3. `termLength` is not equal to block.timestamp
    ///     S4. the tokens streamed per second cannot be less than 1 wei
    ///     S5. the `tokensToStream` is a multiple of `termLength`
    ///
    /// RESI: given the above, this function will:
    ///     RESI-1. Stores the msg.sender as the `arbitrator`
    ///     RESI-2. Stores the `_sablier` param
    ///     RESI-3. Stores the `_agreement` param
    ///     RESI-4. Approves `sablier` to spend `tokensToStream`
    ///     RESI-5. Initializes a sablier stream
    ///
    /// RETURNS: the sablier streamId
    function initialize(
        ISablier _sablier,
        address streamToken,
        uint256 tokensToStream,
        uint256 termLength,
        Agreement calldata _agreement
    ) public initializer returns (uint256 streamId) {
        arbitrator = AgreementArbitrator(msg.sender);
        sablier = _sablier;
        agreement = _agreement;

        IERC20(streamToken).approve(address(_sablier), tokensToStream);

        streamId = sablier.createStream({
            recipient: _agreement.provider,
            deposit: tokensToStream,
            tokenAddress: address(streamToken),
            startTime: block.timestamp,
            stopTime: block.timestamp + termLength
        });
    }
}

/**
 * - DAO: legal entity name, type, and jurisdiction
 *     - SP: legal entity name, type, jurisdiction
 *     - SP's counterparty for agreement address
 *     - agreement scope of work
 *     - term length
 *     - stream token
 *     - total tokens streamed over term
 *     - [x] at will (n amount of days) (optional)
 *     - [x] mutual consent (always enabled)
 *     - [x] material breach (always enabled) (n amount of days to cure breach)
 *     - rage terminate (optional, select from choices below)
 * legal compulsion
 * counterparty malfeasance (indictment, fraud, sanctions, crimes of moral turpitude)
 * bankruptcy, dissolution, insolvency, loss of necessary license/certification
 * counterparty lost exclusive control over private keys
 */
